#include <metal_stdlib>
using namespace metal;

/* 
 This file contains Metal shader functions for flowshop scheduling evaluation
 and Pareto dominance checking. It's optimized for Apple Silicon's unified memory
 architecture to minimize data transfers.
*/

// Maximum number of jobs and machines we'll support
constant int MAX_JOBS = 200;
constant int MAX_MACHINES = 10;

/// Evaluate a single flowshop solution on GPU
kernel void evaluate_flowshop(
    device const uint* jobSequence [[buffer(0)]],            // Input job sequence
    device const float* processingTimes [[buffer(1)]],       // Processing times matrix (flattened)
    device const float* priorities [[buffer(2)]],            // Job priorities
    device const float* deadlines [[buffer(3)]],             // Job deadlines
    device float2* objectives [[buffer(4)]],                 // Output objectives (makespan, tardiness)
    device const uint& numJobs [[buffer(5)]],                // Number of jobs
    device const uint& numMachines [[buffer(6)]],            // Number of machines
    device const uint& numSolutions [[buffer(7)]],           // Number of solutions to evaluate
    uint solutionIndex [[thread_position_in_grid]]           // Solution being evaluated by this thread
) {
    // Check that we don't exceed array bounds
    if (solutionIndex >= numSolutions) {
        return;
    }

    // Calculate completion times of each job on each machine
    float completionTimes[MAX_MACHINES];
    for (uint m = 0; m < numMachines; m++) {
        completionTimes[m] = 0.0f;  // Initialize to zero
    }
    
    float totalWeightedTardiness = 0.0f;
    
    // Process each job in the sequence
    for (uint j = 0; j < numJobs; j++) {
        // Get the job ID from the sequence
        uint jobId = jobSequence[solutionIndex * numJobs + j];
        
        // Ensure job ID is in bounds
        if (jobId >= numJobs) {
            continue;  // Skip this job if ID is invalid
        }
        
        // Calculate completion time on first machine
        completionTimes[0] += processingTimes[jobId * numMachines + 0];
        
        // Calculate completion times on subsequent machines
        for (uint m = 1; m < numMachines; m++) {
            // Each job must wait for previous machine to complete
            completionTimes[m] = max(completionTimes[m], completionTimes[m-1]);
            
            // Add processing time on current machine
            completionTimes[m] += processingTimes[jobId * numMachines + m];
        }
        
        // Calculate tardiness contribution of this job
        float jobCompletionTime = completionTimes[numMachines - 1];
        float jobDeadline = deadlines[jobId];
        float jobTardiness = max(0.0f, jobCompletionTime - jobDeadline);
        float jobPriority = priorities[jobId];
        
        // Add weighted tardiness to total
        totalWeightedTardiness += jobTardiness * jobPriority;
    }
    
    // Store makespan (completion time of last job on last machine)
    float makespan = completionTimes[numMachines - 1];
    
    // Save objectives
    objectives[solutionIndex] = float2(makespan, totalWeightedTardiness);
}

/// Generate a random permutation using PCG random number generator
static void generate_permutation(
    thread uint* sequence,
    uint length,
    uint seed,
    uint sequence_idx
) {
    // Initialize PCG state
    uint state = seed + sequence_idx * 1013904223;
    
    // Fisher-Yates shuffle
    for (uint i = 0; i < length; i++) {
        sequence[i] = i;
    }
    
    for (uint i = length - 1; i > 0; i--) {
        // PCG random number generation
        state = state * 747796405 + 2891336453;
        uint word = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
        uint next = (word >> 22) ^ word;
        
        // Random index between 0 and i
        uint j = next % (i + 1);
        
        // Swap elements i and j
        uint temp = sequence[i];
        sequence[i] = sequence[j];
        sequence[j] = temp;
    }
}

/// Generate and evaluate random solutions on GPU
kernel void generate_and_evaluate_flowshop(
    device uint* outputSequences [[buffer(0)]],              // Output job sequences
    device const float* processingTimes [[buffer(1)]],       // Processing times matrix (flattened)
    device const float* priorities [[buffer(2)]],            // Job priorities
    device const float* deadlines [[buffer(3)]],             // Job deadlines
    device float2* objectives [[buffer(4)]],                 // Output objectives (makespan, tardiness)
    device const uint& numJobs [[buffer(5)]],                // Number of jobs
    device const uint& numMachines [[buffer(6)]],            // Number of machines
    device const uint& numSolutions [[buffer(7)]],           // Number of solutions to generate
    device const uint& seed [[buffer(8)]],                   // Random seed
    uint solutionIndex [[thread_position_in_grid]]           // Solution being generated by this thread
) {
    // Check that we don't exceed array bounds
    if (solutionIndex >= numSolutions) {
        return;
    }
    
    // Local array for the job sequence
    uint jobSequence[MAX_JOBS];
    
    // Generate a random permutation
    generate_permutation(jobSequence, numJobs, seed, solutionIndex);
    
    // Store the permutation in global memory
    for (uint j = 0; j < numJobs; j++) {
        outputSequences[solutionIndex * numJobs + j] = jobSequence[j];
    }
    
    // Calculate completion times of each job on each machine
    float completionTimes[MAX_MACHINES];
    for (uint m = 0; m < numMachines; m++) {
        completionTimes[m] = 0.0f;  // Initialize to zero
    }
    
    float totalWeightedTardiness = 0.0f;
    
    // Process each job in the sequence
    for (uint j = 0; j < numJobs; j++) {
        // Get the job ID from the sequence
        uint jobId = jobSequence[j];
        
        // Calculate completion time on first machine
        completionTimes[0] += processingTimes[jobId * numMachines + 0];
        
        // Calculate completion times on subsequent machines
        for (uint m = 1; m < numMachines; m++) {
            // Each job must wait for previous machine to complete
            completionTimes[m] = max(completionTimes[m], completionTimes[m-1]);
            
            // Add processing time on current machine
            completionTimes[m] += processingTimes[jobId * numMachines + m];
        }
        
        // Calculate tardiness contribution of this job
        float jobCompletionTime = completionTimes[numMachines - 1];
        float jobDeadline = deadlines[jobId];
        float jobTardiness = max(0.0f, jobCompletionTime - jobDeadline);
        float jobPriority = priorities[jobId];
        
        // Add weighted tardiness to total
        totalWeightedTardiness += jobTardiness * jobPriority;
    }
    
    // Store makespan (completion time of last job on last machine)
    float makespan = completionTimes[numMachines - 1];
    
    // Save objectives
    objectives[solutionIndex] = float2(makespan, totalWeightedTardiness);
}

/// Check if one solution dominates another with bi-objective optimization
kernel void check_dominance(
    device const float2* objectives [[buffer(0)]],         // Array of objective values (makespan, tardiness)
    device atomic_int* dominanceMatrix [[buffer(1)]],      // Output dominance matrix (1 if row dominates column)
    device const uint& numSolutions [[buffer(2)]],         // Number of solutions
    uint2 position [[thread_position_in_grid]]             // Position in the dominance matrix
) {
    // Get indices for the two solutions to compare
    uint i = position.x;
    uint j = position.y;
    
    // Skip diagonal elements (same solution) and out-of-bounds
    if (i >= numSolutions || j >= numSolutions || i == j) {
        return;
    }
    
    // Get the objectives for both solutions
    float2 obj_i = objectives[i];
    float2 obj_j = objectives[j];
    
    // For minimization: solution i dominates solution j if it's at least as good
    // in all objectives and strictly better in at least one
    bool atLeastAsGoodInAll = (obj_i.x <= obj_j.x) && (obj_i.y <= obj_j.y);
    bool strictlyBetterInOne = (obj_i.x < obj_j.x) || (obj_i.y < obj_j.y);
    
    // If dominates, mark in the matrix
    if (atLeastAsGoodInAll && strictlyBetterInOne) {
        atomic_store_explicit(dominanceMatrix + (i * numSolutions + j), 1, memory_order_relaxed);
    }
}